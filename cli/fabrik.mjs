#!/usr/bin/env node
/*
  Fabrik Interactive CLI
  - Gathers environment, roles/tribes, and psyche profile
  - Produces ./fabrik/out/config.fabrik.json and .env suggestions
*/
import fs from 'fs';
import path from 'path';
import readline from 'readline';
import os from 'os';

const args = process.argv.slice(2);
let outDir = './fabrik/out';
let interactive = false;
let subcmd = '';
for (let i=0;i<args.length;i++){
  const a = args[i];
  if(a==='--out' && args[i+1]){ outDir = args[++i]; }
  else if(a==='--interactive'){ interactive = true; }
  else if(!a.startsWith('-') && !subcmd){ subcmd = a; }
}

if(!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });

const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
const ask = (q)=> new Promise(res=> rl.question(q, ans=> res(ans.trim())));

function likert(name){
  return ask(`Rate ${name} (1-5): `).then(v=> Math.max(1, Math.min(5, parseInt(v||'3',10))));
}

async function genBundleConfig(){
  console.log('\nFabrik CLI — minimal factory bundle generator');
  const cfg = {
    app: {
      baseUrl: process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3101',
      cors: (process.env.NEXT_PUBLIC_CORS_ORIGINS||'http://localhost:3101').split(',').map(s=>s.trim())
    },
    mongo: {
      url: process.env.MONGO_URL || 'mongodb://mongo:27017/factory?authSource=admin',
      db: process.env.MONGO_DB || 'factory'
    },
    roles: ['admin'],
    tribes: [],
    psyche: {}
  };

  if(interactive){
    cfg.app.baseUrl = await ask(`Base URL [${cfg.app.baseUrl}]: `) || cfg.app.baseUrl;
    const cors = await ask(`CORS origins (comma) [${cfg.app.cors.join(',')}]: `);
    if(cors) cfg.app.cors = cors.split(',').map(s=>s.trim());
    cfg.mongo.url = await ask(`Mongo URL [${cfg.mongo.url}]: `) || cfg.mongo.url;
    const r = await ask('Roles (comma) [admin]: ');
    if(r) cfg.roles = r.split(',').map(s=>s.trim());
    const t = await ask('Tribes (comma) []: ');
    if(t) cfg.tribes = t.split(',').map(s=>s.trim());
    console.log('\nPsychometrics — Likert 1..5');
    const dims = ['blossoming','emancipation','depth','substance','emotion','critic','tension','meditation'];
    for(const d of dims){ cfg.psyche[d] = await likert(d); }
  }

  const outFile = path.join(outDir, 'config.fabrik.json');
  fs.writeFileSync(outFile, JSON.stringify(cfg, null, 2));
  console.log(`\nWrote ${outFile}`);

  const envTip = `# Generated by Fabrik CLI\nNEXT_PUBLIC_BASE_URL=${cfg.app.baseUrl}\nNEXT_PUBLIC_CORS_ORIGINS=${cfg.app.cors.join(',')}\nMONGO_URL=${cfg.mongo.url}\nMONGO_DB=${cfg.mongo.db}\n`;
  const envOut = path.join(outDir, 'fabrik.env');
  fs.writeFileSync(envOut, envTip);
  console.log(`Wrote ${envOut}`);
}

async function hypernodeInit(){
  console.log('\nFabrik CLI — hypernode init');
  const base = await ask(`Factory URL [${process.env.FACTORY_BASE_URL||'http://localhost:3101'}]: `) || process.env.FACTORY_BASE_URL || 'http://localhost:3101';
  const name = await ask(`Node name [${process.env.HYPERNODE_NAME||os.hostname()}]: `) || process.env.HYPERNODE_NAME || os.hostname();
  const traits = await ask('Traits JSON (optional) [{}]: ') || '{}';
  const env = [
    `FACTORY_BASE_URL=${base}`,
    `HYPERNODE_NAME=${name}`,
    `HYPERNODE_TRAITS=${traits}`,
  ].join('\n');
  const p = path.join(process.cwd(), 'fabrik', 'hypernode', '.env');
  fs.mkdirSync(path.dirname(p), { recursive: true });
  fs.writeFileSync(p, env+'\n');
  console.log('Wrote', p);
}

async function hypernodeJoin(){
  console.log('\nFabrik CLI — hypernode join');
  const base = process.env.FACTORY_BASE_URL || 'http://localhost:3101';
  const url = base.replace(/\/$/,'') + '/api/fabrik/hypernode/handshake';
  const stateFile = path.join(process.cwd(), 'fabrik', 'hypernode', 'state.json');
  let state = {}; try{ state = JSON.parse(fs.readFileSync(stateFile,'utf8')); }catch{}
  const id = (state&&state.id) || ('');
  const body = { id, name: process.env.HYPERNODE_NAME||'fabrik-hypernode', traits: (()=>{ try{ return JSON.parse(process.env.HYPERNODE_TRAITS||'{}'); }catch{ return {}; } })(), host: { platform: os.platform(), arch: os.arch(), version: process.version } };
  const res = await fetch(url, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
  if(!res.ok){ console.error('[join] handshake failed:', res.status); process.exit(1); }
  const j = await res.json();
  console.log('Handshake:', j);
  fs.mkdirSync(path.dirname(stateFile), { recursive: true });
  fs.writeFileSync(stateFile, JSON.stringify({ ...(state||{}), id: j.id, token: j.token }, null, 2));
  console.log('Updated state file');
}

async function bundle(){
  console.log('\nFabrik CLI — bundle');
  const srcDir = path.join(process.cwd(), 'fabrik');
  const distDir = path.join(process.cwd(), 'fabrik', 'dist');
  fs.mkdirSync(distDir, { recursive: true });
  const outfile = path.join(distDir, 'fabrik-bundle.tar.gz');
  // Portable: use system tar if available; otherwise, write a simple zip-less tarball is complex; assume tar exists.
  const { spawnSync } = await import('node:child_process');
  const r = spawnSync('tar', ['-czf', outfile, '-C', srcDir, '.'], { stdio: 'inherit' });
  if(r.status!==0){ console.error('tar failed'); process.exit(1); }
  console.log('Bundle ready:', outfile);
}

async function main(){
  if(subcmd==='hypernode'){
    const cmd = args.find(a=> ['init','join','bundle','service','vpn-template'].includes(a));
    if(cmd==='init') { await hypernodeInit(); rl.close(); return; }
    if(cmd==='join') { await hypernodeJoin(); rl.close(); return; }
    if(cmd==='bundle') { await bundle(); rl.close(); return; }
    if(cmd==='service') {
      const cwd = process.cwd();
      const unit = `[#] Copy to /etc/systemd/system/hypernode.service and adjust paths as needed\n[Unit]\nDescription=Fabrik Hypernode Runner\nAfter=network-online.target\nWants=network-online.target\n\n[Service]\nType=simple\nWorkingDirectory=${cwd}\nEnvironmentFile=${cwd}/fabrik/hypernode/.env\nExecStart=/usr/bin/env node fabrik/hypernode/runner.mjs\nRestart=on-failure\nRestartSec=5\n\n[Install]\nWantedBy=multi-user.target\n`;
      const out = path.join(process.cwd(), 'fabrik', 'hypernode', 'systemd', 'hypernode.service');
      fs.mkdirSync(path.dirname(out), { recursive: true });
      fs.writeFileSync(out, unit, 'utf8');
      console.log('Wrote', out);
      console.log('Install with: sudo cp', out, '/etc/systemd/system/hypernode.service && sudo systemctl daemon-reload && sudo systemctl enable --now hypernode');
      rl.close();
      return;
    }
    if(cmd==='vpn-template') {
      async function vpnTemplate(){
        const base = process.env.FACTORY_BASE_URL || '';
        const id = (await ask(`Node id (hn:...) [auto]: `)) || '';
        const pub = (await ask(`Client public key (base64): `));
        if(!pub){ console.error('Public key required'); process.exit(1); }
        const net = process.env.VPN_WG_NET || '10.8.0.0/24';
        const allowed = process.env.VPN_WG_ALLOWED_IPS || '0.0.0.0/0, ::/0';
        const endpoint = process.env.VPN_WG_ENDPOINT || 'vpn.example.com:51820';
        const serverPub = process.env.VPN_WG_SERVER_PUBKEY || 'SERVER_PUBKEY_BASE64';
        const dns = process.env.VPN_WG_DNS || '1.1.1.1';
        const crypto = await import('node:crypto');
        function hashByte(s){ const h=crypto.createHash('sha256').update(s).digest(); let b=h[h.length-1]; if(b<2) b=2; if(b>254) b=254; return b; }
        function deriveAddr(nodeId){ const [netBase, cidr] = net.split('/'); const oct = netBase.split('.').map(s=> parseInt(s,10)); const host = hashByte(nodeId||pub); return `${oct[0]}.${oct[1]}.${oct[2]}.${host}/${cidr||'24'}`; }
        const addr = deriveAddr(id);
        const cfg = [
          '[Interface]',
          `Address = ${addr}`,
          `DNS = ${dns}`,
          'PrivateKey = # fill in your private key',
          '',
          '[Peer]',
          `PublicKey = ${serverPub}`,
          `AllowedIPs = ${allowed}`,
          `Endpoint = ${endpoint}`,
          '# PersistentKeepalive = 25',
        ].join('\n');
        const outDir = path.join(process.cwd(), 'fabrik', 'hypernode'); fs.mkdirSync(outDir,{recursive:true});
        const out = path.join(outDir, `vpn-${(id||'node').replace(/[^a-z0-9:_-]/gi,'_')}.conf`);
        fs.writeFileSync(out, cfg, 'utf8');
        console.log('Wrote', out);
      }
      await vpnTemplate();
      rl.close();
      return;
    }
  }
  await genBundleConfig();
  rl.close();
}

main().catch(e=>{ console.error(e); process.exit(1); });
